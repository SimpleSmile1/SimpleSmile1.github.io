<html>
<head>
<title>PHP知识点:</title>
</head>
<body>
<h2 style="text-align:center">PHP要点</h2>

<h3>php注意事项</h3>
<span>
1、单引号和双引号的区别: 在php中双引号里的字段会经过编译器解释，然后再当作HTML代码输出；单引号里面的不进行解释，直接输出。
</span>
<h3>php知识点:</h3>
<p>1、1.PHP和HTML可以混写 &emsp;&emsp;2.PHP变量的数据类型是变化的&emsp;&emsp; 3.PHP变量的数据类型是由运行时的上下文决定</p>
<p>2、变量总是属于某种类型 变量是具体的 类型是抽象的</p>
<p>3、代码的健壮性、代码的可扩展性、代码的安全性、代码的效率（并发、速度）</p>
<p>4、PHP中$a变量没有赋值时 var_dump($a)输出一个NULL</p>
<p>5、PHP中的整数都是有符号的，php不支持无符号的数</p>
<p>6、PHP中定义字符串可以用双引号或者单引号</p>
<p>7、在PHP中当一个变量包含在双引号中时，会输出它的值，而包含在单引号中时输出其字符本身</p>
<p>8、php三元运算符: 表达式1？表达式2：表达式3</p>
<p>9、php字符串运算符，字符串连接符是点 (.)</p>
<p>10、php中switch语句 case 后的常亮可以是 int float 字符串 bool null; switch(表达式) 里的表达式如果是'1'字符串1则会转换长整数1进行匹配</p>
<p>11、php中常量通过define函数或const来定义define("常量名"，常量值)、const 常量名 = 常量值</p>
<h3>PHP函数:</h3>
<p>1、自定义函数的基本语法: function 函数名(参数列表){ 函数体; return语句(可以有，可以没有) }</p>
<p>2、php中函数名不能一样</p>
<p>3、php通过require、require_once或include、include_once方法把一个php页面引入到另一个php页面中</p>
<p>4、require对同一个页面可以引入多次，require_once对同一个页面只引入一次。include、include_once同理</p>
<p>5、require和include区别: require如果引入出错则终止程序执行，include引入出错不终止执行</p>

<h3>数组:</h3>
<span>
<p>1、php中数组是一组关键字和值的集合，值可以是任何一种类型。</p>
<p>2、通过函数count计算数组中的元素个数-->count(数组名);</p>
<p>3、创建数组: 如: $array[0]=1; $array[1]=2;$array[2]=3; 几个注意事项:①[0]: 称为下标或关键字②$array[0]: 称为数组的一个元素③1: 表示该$array[0]元素对应的值④$array: 是该数组的名称</p>
<p>4、创建数组的第二种方式 : $arr = array(1,2,3);</p>
<p>5、创建数组的第三种方式: 默认情况下元素的下标是从0开始编号的，但是我们也可以自己指定。基本语法: $array['logo']='北京';$array['aa']=123;或者$arr=array("logo"=>"北京"，"aa"=>123),此时需要foreach进行遍历foreach($arr as 变量1=>变量2)</p>
<p>6、php数组可以动态增长</p>
<p>7、php把数组当作参数传递给函数不是按引用传递的，如果想把数组的地址传递给函数需要在数组名前加上取地址符&。如 :  定义一个数组: $arr=array(.....); 调用函数fun（$arr）; function fun（&$arr）{}此时函数fun接收到数组的地址。</p>
<p>8、php中二维数组: 二维数组定义: $arr = array(array(1,2),array(3,4));或$arr[] = array(1,2);</p>

<h3>类与对象</h3>
<span>
<h4>类与对象的区别和联系:</h4>
<p>1、类是抽象的、概念的，代表一类事物，比如人类、猫类、、、、</p>
<p>2、对象的具体的、实际的，代表一个具体事物。</p>
<p>3、类是对象的模板，对象是类的一个个体实例。</p>
<p>4、类就是一种特殊的数据类型。</p>
<p>5、对象当作参数传递给函数是把对象的引用传递给了函数。</p>
<p>6、基本类型当作参数传递的是值，如果希望传入地址则写:function 函数名(&$变量名){}。</p>
<p>7、php构造方法没有返回值，系统会自动调用构造方法。构造函数定义: __construct(){}</p>
<p>8、析构函数定义: __destruct(){} ; php中的析构函数作用: 释放资源。析构函数会被自动调用。析构函数主要用于销毁资源。析构函数的调用顺序是，先创建的对象后被销毁。</p>
<p>9、析构函数调用机制: ①当程序退出时（进程结束）②当一个对象成为垃圾对象时，该对象的析构函数也会被调用。③一旦一个对象成为垃圾对象，析构函数就会立即调用。</p>
<p>10、1）析构函数没有返回值。2）主要作用是释放资源的操作，不是销毁对象本身。3）在销毁对象前，系统自动的调用该类的析构方法。4）一个类最多只有一个析构方法。</p>
</span>

<h3>静态变量和静态方法</h3>
<span>
<p>1、全局变量: 全局变量定义 global $变量名; 全局变量定义和赋值需要分开。</p>
<p>2、静态变量: 静态变量定义 public static $变量名。静态变量属于整个类。</p>
<p>3、静态变量的访问: 在类内部访问方式有两种①self::$静态变量名或 类名::$静态变量名。在类外部访问有一种方式: 类名::$静态变量</p>
<p>4、静态方法是属于所有对象实例的，静态方法定义: 访问修饰符 static function 方法名(){}。静态方法访问: 在外部->类名::类方法名或对象名->类方法名。在内部->self::类方法名或类名::类方法名。</p></p></p></p>
<p>5、注意: 类方法中不能访问非静态属性(变量)。</p>
<p>6、静态方法特点: ①静态方法操作静态变量②静态方法不能操作非静态变量③普通的成员方法即可以操作静态变量又可以操作非静态变量。</p>
</span>

<h3>封装性</h3>
<span>
<p>1、权限修饰符 : public : 类外部、本类里、子类都可以访问。protected : 本类、子类可以访问。private : 只有本类可以访问。三个修饰符可以对变量方法进行修饰。</p>
<p>2、方法如果没有访问修饰符则默认是public，变量则必须指定访问修饰符。</p>
<p>3、方法可以调用方法，但必须用$this来引用。</p>
<p>4、function __set($property_name,$property_value){$this->property_name = $property_value} __set方法可以管理所有的属性。function __get($property_name){return $this->property_name} __get方法可以获取所有属性值。</p>
</span>
<h3>继承性</h3>
<span>
<p>1、如果一个类想继承多个类的属性和方法，可以通过多层继承实现。</p>
<p>2、php中创建子类对象时不会自动调用父类的构造方法，与java有区别。</p>
<p>3、如果我们希望调用父类的构造方法或者其他的方法，可以通过以下方法: 父类名::方法名()或parent::方法名()进行访问。</p>
</span>

<h3>多态性</h3>
<span>
<p>1、overload方法的重载，函数名相同，通过函数的参数个数或者参数类型不同，达到调用同一个函数名，但是可以区分不同的函数。目前php不支持方法的重载，但可通过魔术函数__call()来间接实现。__call()方法是当一个对象调用某个方法时，而该方法又不存在则系统会自动调用__call()。</p>
<p>2、override方法的重写，当子类方法和父类方法完全一样，我们称之为方法的重写或方法的覆盖。</p>
<p>3、简单的说:方法重写解释子类有一个方法和父类的某个方法的名称、参数个数一样（参数的名称可以不一样），那么我们就说子类里的方法重写了父类里的方法。</p>
<p>4、实现方法的重写时，访问修饰符可以不一样，但是必须满足子类的访问范围大于等于父类的访问范围。</p>
</span>

<h3>抽象类</h3>
<span>
<p>1、基本语法: abstract class 类名{}</p>
<p>2、如果一个类用abstract修饰，则该类是抽象类。如果一个方法被abstract修饰，则该方法是抽象方法，抽象方法不能有方法体。</p>
<p>3、抽象类可以没有抽象方法，也可以有实现了的方法。</p>
</span>

<h3>接口</h3>
<span>
<p>1、接口的基本语法: interface 接口名{}，接口里的方法不能有方法体。接口的特点体现出高内聚低耦合。</p>
<p>2、什么时候可以用接口:①定规范②定下规范让别的程序员去实现③当多个类它们之间是平级的关系，这些类都会去实现某个功能，只是实现的方式不一样。</p>
<p>3、接口的注意事项:①接口不能被实例化②接口中所有的方法都不能有主体③一个类可以实现多个接口用逗号隔开④接口中可以有属性但必须是常量，默认是public⑤接口中的方法必须是public，默认是是public⑥一个接口不能继承其他的类，但可以继承多个其它的接口。</p>
<p>4、继承和实现接口的比较:①可以认为实现接口是对单一继承的补充②可以在不破坏类层级关系的前提下，对某个类功能扩展。</p>

<h3>final关键字</h3>
<p>1、用final修饰的类不能被继承，用final修饰的方法不能被重写。</p>
<p>2、什么时候用final:①出于安全考虑某个方法不想被重写②不希望某个类被其它类继承</p>

<h3>const常量</h3>
<p>1、基本用法: const 常量名 = 常量值; 注意：常量名应全部大写，且前面不加$，const前不需要修饰符。</p>
<p>2、访问常量: 在类的外部：类名::常量名。在类的内部：类名::常量名或self::常量名</p>
<p>3、常量的值定义时必须初始化以后不能被修改。常量可以被子类继承。一个常量属于一个类，而不是属于某个对象。</p>
<p>4、常量什么时候用①当某个值固定不变的时候</p>
</span>

<h3>错误和异常处理</h3>
<span>
<p>1、php处理错误的三种方式①使用简单的die语句如:if(!file_exists("aa.txt")){die(“文件不存在”)}else{}或者file_exists("aa.txt") or die(“文件不存在”)</p>
<p>2、用户自定义错误处理函数:function my_error(错误级别，错误信息，....){} ,设置错误回调函数：set_error_hanlder("my_error",错误级别)。</p>
<p>3、错误处理触发器:trigger_error()调用触发器同时指定错误级别。</p>
<p>4、关键字try、catch、throw</p>
</span>
<h3>内存分布图:</h3>
<div>&emsp;<img src="memory.png"></div>

<h3>浏览网页流程:</h3>
<div>&emsp;<img src="visitweb.png"></div>
</body>
</html>